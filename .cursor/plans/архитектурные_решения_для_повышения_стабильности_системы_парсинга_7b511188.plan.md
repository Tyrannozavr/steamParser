---
name: Архитектурные решения для повышения стабильности системы парсинга
overview: "Анализ логов и кода выявил проблемы со стабильностью: задачи зависают, много таймаутов, проблемы с наклейками, отсутствие устойчивости к ошибкам. Предлагаю несколько архитектурных подходов для повышения надежности системы."
todos:
  - id: analyze-logs
    content: Проанализировать логи 1234.txt для выявления паттернов ошибок и проблем со стабильностью
    status: completed
  - id: choose-approach
    content: Выбрать архитектурный подход на основе анализа (Вариант 1, 2, 3 или 4)
    status: completed
  - id: implement-chosen
    content: Реализовать выбранный архитектурный подход с улучшениями стабильности
    status: completed
  - id: fix-stickers
    content: Исправить проблему с наклейками - добавить fallback механизмы для получения цен
    status: pending
  - id: improve-timeouts
    content: Улучшить обработку таймаутов - динамические таймауты и разбиение больших задач
    status: pending
  - id: add-monitoring
    content: Добавить мониторинг и метрики для отслеживания здоровья системы
    status: pending
---

# Анализ проблем и архитектурные решения

## Выявленные проблемы

### 1. Критические проблемы стабильности

- **705 таймаутов** в логах - указывает на проблемы с прокси/сетью
- **Задачи зависают** - задачи 17, 18 выполняются 10+ минут
- **Мониторинг останавливается** при 5 последовательных ошибках (MAX_CONSECUTIVE_ERRORS=5)
- **Отсутствие retry механизма** для failed задач в очереди
- **ACK происходит до обработки** - при ошибке задача теряется

### 2. Проблемы с наклейками

- Некоторые наклейки не находят цену (StickerPricesAPI возвращает None)
- Нет fallback механизма для критических наклеек

### 3. Архитектурные слабости

- Redis Streams ACK происходит сразу после получения сообщения (строка 333 в `redis_service.py`)
- При ошибке обработки задача теряется (нет retry)
- Нет механизма обработки pending messages (зависшие сообщения)
- Мониторинг останавливается при ошибках вместо продолжения работы

## Предлагаемые архитектурные решения

### Вариант 1: Улучшение Redis Streams с правильным ACK и retry

**Суть:** Исправить текущую архитектуру Redis Streams, добавив правильную обработку ошибок и retry механизм.

**Изменения:**

1. **Отложенный ACK** - подтверждать сообщение только после успешной обработки
2. **Pending messages обработка** - периодически проверять и переобрабатывать зависшие сообщения
3. **Retry механизм** - автоматически повторять failed задачи с экспоненциальной задержкой
4. **Dead Letter Queue** - перемещать задачи после N неудачных попыток в DLQ для ручного разбора

**Файлы для изменения:**

- `services/redis_service.py` - добавить методы для обработки pending messages и DLQ
- `parsing/parsing_worker.py` - переместить ACK в конец обработки, добавить retry логику
- `services/monitoring_service.py` - убрать остановку при ошибках, только логировать

**Преимущества:**

- Минимальные изменения в архитектуре
- Быстрая реализация
- Сохраняет текущую инфраструктуру

**Недостатки:**

- Все еще зависит от Redis
- Нет гарантий доставки (Redis может потерять данные)

---

### Вариант 2: Переход на RabbitMQ с гарантиями доставки

**Суть:** Заменить Redis Streams на RabbitMQ для надежной обработки задач с гарантиями доставки.

**Изменения:**

1. **RabbitMQ очередь** с durable=True, delivery_mode=2 (persistent)
2. **Manual ACK** - подтверждать только после успешной обработки
3. **Dead Letter Exchange** - автоматически перемещать failed задачи
4. **Retry с экспоненциальной задержкой** через delayed message exchange
5. **Приоритеты задач** - критичные задачи обрабатываются первыми

**Новые компоненты:**

- `services/rabbitmq_service.py` - новый сервис для работы с RabbitMQ
- Обновить `docker-compose.yml` - добавить RabbitMQ контейнер
- `parsing/parsing_worker.py` - адаптировать под RabbitMQ

**Преимущества:**

- Гарантии доставки (persistent messages)
- Встроенные механизмы retry и DLQ
- Приоритеты и routing
- Мониторинг через RabbitMQ Management UI
- Высокая надежность

**Недостатки:**

- Требует добавления нового сервиса (RabbitMQ)
- Больше изменений в коде
- Нужна миграция с Redis на RabbitMQ

---

### Вариант 3: Гибридный подход - Circuit Breaker + улучшенный мониторинг

**Суть:** Добавить Circuit Breaker паттерн и улучшить обработку ошибок без смены брокера.

**Изменения:**

1. **Circuit Breaker** для критических операций (парсинг, получение цен наклеек)
2. **Улучшенный мониторинг** - задачи НИКОГДА не останавливаются, только логируются ошибки
3. **Graceful degradation** - при ошибках наклеек продолжать работу без них
4. **Health checks** - периодическая проверка здоровья задач
5. **Автоматическое восстановление** - перезапуск зависших задач

**Новые компоненты:**

- `services/circuit_breaker.py` - реализация Circuit Breaker паттерна
- `services/health_checker.py` - периодическая проверка здоровья задач
- Улучшить `services/monitoring_service.py` - убрать остановку при ошибках

**Преимущества:**

- Не требует смены инфраструктуры
- Задачи продолжают работать даже при ошибках
- Автоматическое восстановление
- Изоляция ошибок (одна задача не влияет на другие)

**Недостатки:**

- Все еще возможны потери задач при критических ошибках Redis
- Требует тщательной настройки thresholds

---

### Вариант 4: Event Sourcing + Saga Pattern для максимальной надежности

**Суть:** Использовать Event Sourcing для отслеживания состояния задач и Saga для координации сложных операций.

**Изменения:**

1. **Event Store** - все события задач сохраняются в БД
2. **Saga Pattern** - координация многошаговых операций (парсинг -> обработка -> уведомление)
3. **Compensating transactions** - откат при ошибках
4. **State machine** - четкое управление состояниями задач
5. **Event replay** - возможность восстановления состояния из событий

**Новые компоненты:**

- `services/event_store.py` - хранение событий
- `services/saga_coordinator.py` - координация саг
- Обновить модели БД - добавить таблицы событий

**Преимущества:**

- Максимальная надежность и traceability
- Возможность восстановления из событий
- Аудит всех операций

**Недостатки:**

- Сложная реализация
- Большие изменения архитектуры
- Overhead на хранение событий

---

## Рекомендации по реализации

### Для быстрого улучшения (1-2 дня):

**Вариант 1** - исправить ACK и добавить retry в Redis Streams

### Для долгосрочной стабильности (1 неделя):

**Вариант 2** - переход на RabbitMQ

### Для максимальной надежности без смены инфраструктуры (3-5 дней):

**Вариант 3** - Circuit Breaker + улучшенный мониторинг

### Для enterprise уровня (2-3 недели):

**Вариант 4** - Event Sourcing + Saga

## Дополнительные улучшения (для всех вариантов)

1. **Улучшение обработки наклеек:**

- Добавить fallback на несколько источников цен
- Кэшировать неудачные попытки (чтобы не повторять запросы)
- Использовать fuzzy matching более агрессивно

2. **Улучшение обработки таймаутов:**

- Динамические таймауты в зависимости от размера задачи
- Автоматическое увеличение таймаута при больших задачах
- Разбиение больших задач на подзадачи

3. **Мониторинг и алертинг:**

- Метрики успешности задач
- Алерты при превышении порога ошибок
- Dashboard для отслеживания здоровья системы